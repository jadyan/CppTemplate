<!--
 * @Author: your name
 * @Date: 2021-06-25 10:06:43
 * @LastEditTime: 2021-06-25 10:06:44
 * @LastEditors: your name
 * @Description: In User Settings Edit
 * @FilePath: /jadyan/code/book/CppTemplate/read/13_template_polymorphism/13_03_dynamic_static_polymorphism/readme.md
-->
14.3 动多态和静多态
我们来对多态进行分类，并对这两种多态进行比较。
14.3.1 术语
动多态和静多态为不同的C++编程idioms提供了支持[3]：
•通过继承实现的多态是绑定的和动态的：
绑定的含义是：对于参与多态行为的类型，它们（具有多态行
为）的接口是在公共基类的设计中就预先确定的（有时候也把绑定这
个概念称为入侵的或者插入的）。

动态的含义是：接口的绑定是在运行期（动态）完成的。
•通过模板实现的多态是非绑定的和静态的：
非绑定的含义是：对于参与多态行为的类型，它们的接口是没有
预先确定的（有时也称这个概念为非入侵的或者非插入的）。
静态的含义是：接口的绑定是在编译期（静态）完成的。
因此，严格地讲，在针对C++的说法中，动多态是绑定并且动态的
多态的简称，而静多态则是非绑定并且静态的多态的简称。但是在其
他语言中，还可能会有其他组合存在（例如，Smalltalk 就提供了非绑
定的动态多态）。然而，在 C++的上下文中，动多态和静多态是两个
非常准确的概念，并不会产生混淆。



14.3.2 优点和缺点
C++的动多态具有下列优点：
•能够优雅地处理异类集合。
•可执行代码的大小通常比较小（因为只需要一个多态函数，但对
于静多态而言，为了处理不同的类型，必须生成多个不同的模板实
例）。
•可以对代码进行完全编译；因此并不需要发布实现源码（但是，
分发模板库通常都需要同时分发模板实现的源代码）。

另一方面，C++的静多态则具有下列优点：
•可以很容易地实现内建类型的集合。更广义地说，并不需要通过
公共基类来表达接口的共同性。
•所生成的代码效率通常都比较高（因为并不存在通过指针的间接
调用，而且，可以进行演绎的非虚拟函数具有更多的内联机会）。
•对于只提供部分接口的具体类型，如果在应用程序中只是使用到
这一部分接口，那么也可以使用该具体类型；而不必在乎该类型是否
提供其他部分的接口。
通常而言，与动多态相比，静多态被认为具有更好的类型安全
性；因为静多态在编译期会对所有的绑定操作进行检查。例如，假设
我们尝试把一个错误类型的对象插入到一个容器中，如果这个容器是
根据模板实例化而生成的话，那么几乎不会有危险，因为在编译期就
可以检查出这个错误；但如果该容器所期望的元素是指向公共基类的
指针，那么这些指针最后很有可能会指向不同类型的完整对象，而这
就有可能会插入错误类型的对象。
在实际应用中，对于看起来相同的接口，如果在它们背后隐藏着
一些语义假设的话，那么模板实例化体有时也会导致一些问题。例
如，对于一个假设具有关联运算符 + 的模板，如果基于一个没有关联
该运算符的类型来实例化这个模板，那么就会出现一些问题。然而，
基于继承体系的多态则很少会出现这种语义非匹配的问题，因为公共
接口规范已经在基类中（更加）显式地指定了。


14.3.3 组合这两种多态
显然，你可以组合这两种形式的多态。例如，你可以从一个公共
基类派生出不同种类的几何对象类，从而能够处理属于异类集合的不
同几何对象。另一方面，你仍然可以使用模板来编写针对某种几何对
象的代码。
我们将在第16章中进一步阐述继承和模板的组合。在第16章中，
我们将看到：如何对成员函数的虚拟性进行参数化；当使用基于继承
的奇异递归模板模式（cuiriously recurring template pattern，CRTP）的
时候，静多态要牺牲哪些额外的灵活性。