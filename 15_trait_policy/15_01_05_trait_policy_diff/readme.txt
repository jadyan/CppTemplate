15.1.5 trait和policy：区别在何处
有人可能会给出一个合理的例子，来阐明这样的一个事实：policy
只是trait的一个特殊例子。相反，也有人认为trait只是用来实现一个
policy的。
New Shorter Oxford English Dictionary对这两个词的定义是这样
的：

•trait n…（名词）：用来刻划一个事物的（与众不同的）特性。
•policy n…（名词）：为了某种有益或有利的目的而采用的一系列动作。

根据上面的定义，我们可能只会把policy class这个概念用于表示对某种动作的编码，而且该动作同任何与它组合在一起的模板参数都是正交的。然而， 大多数人都同意 Andrei Alexandrescu 在Modern
C++Design中给出的声明（见[AlexandrescuDesign]的第8页）：
policy和trait具有许多共同点，

但是policy更加注重于行为，而trait则更加注重于类型。
-------policy 像是策略模式   trait工厂

另外，作为引入了trait技术的第1人，Nathan Myers给出了下面这个
更加开放的定义：
trait class：是一种用于代替模板参数的类。作为一个类，它可以是
有用的类型，也可以是常量；作为一个模板，它提供了一种实现“额外
层次间接性”的途径，而正是这种“额外层次间接性”解决了所有的软件
问题。
因此，我们通常都会使用下面这些（并不是非常准确的）定义：

•trait表述了模板参数的一些自然的额外属性。
•policy 表述了泛型函数和泛型类的一些可配置行为（通常都具有被经常使用的缺省值）。
为了更深入地分析这两个概念之间可能的区别，我们给出下面针
对trait的一些事实：
•trait可以是fixed trait（也就是说，不需要通过模板参数进行传递的trait）。
•trait参数通常都具有很自然的缺省值（该缺省值很少会被改写的，或者是不能被改写的）。
•trait参数可以紧密依赖于一个或多个主参数。
•trait通常都是用trait模板来实现的。

对于policy class，我们将会发现下列事实：
•如果不以模板参数的形式进行传递的话，policy class几乎不起作用。
•policy参数并不需要具有缺省值，而且通常都是显式指定这个参数
（尽管许多泛型组件都配置了使用频率很高的缺省policy）。
•policy参数和属于同一个模板的其他模板参数通常都是正交的。
•policy class一般都包含了成员函数。
•policy既可以用普通类来实现，也可以用类模板来实现。
显然，在这两个概念之间只是存在一条模糊的界限，也还存在一些交叉的地方。例如，C++标准库的字符trait同时也定义了诸如比较、
移动和查找字符的函数行为。另外，通过替换这些trait，你可以定义一
个对大小写不敏感的字符串类（见[JosuttisStdLib]的11.2.14小节），而
且仍然保留原来的字符类型。因此，尽管我们把这些字符trait也称为
trait，但是它们却具有一些与policy相关的属性。
